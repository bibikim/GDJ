-- group by

SELECT DEPARTMENT_ID, COUNT(*) AS 사원수
  FROM EMPLOYEES
 WHERE DEPARTMENT_ID IS NOT NULL
 GROUP BY DEPARTMENT_ID
 ORDER BY DEPARTMENT_ID;
 
SELECT MAX(SUM(SALARY)) AS 최대평균, MIN(SUM(SALARY)) AS 최소평균
  FROM EMPLOYEES
 GROUP BY DEPARTMENT_ID;
 
 
 -- join
 
 /* INNER JOIN */
 
-- 1. 부서위치(LOCATION_ID)가 1700인 부서에 근무하는 사원들의 EMPLOYEE_ID, LAST_NAME, DEPARTMENT_NAME을 조회하시오.
-- DEPARTMENTS 테이블 : LOCATION_ID, DEPARTMENT_NAME
-- EMPLOYEES 테이블   : EMPLOYEE_ID, LAST_NAME
SELECT E.EMPLOYEE_ID, E.LAST_NAME, D.DEPARTMENT_NAME
  FROM DEPARTMENTS D INNER JOIN EMPLOYEES E
    ON D.DEPARTMENT_ID = E.DEPARTMENT_ID   -- 두 테이블의 조인 조건(성능을 위해 앞: pk, 뒤:fk)
 WHERE D.LOCATION_ID = 1700;

-- 이너조인 쓰지 않고 풀이
SELECT E.EMPLOYEE_ID, E.LAST_NAME, D.DEPARTMENT_NAME
  FROM DEPARTMENTS D, EMPLOYEES E
 WHERE D.DEPARTMENT_ID = E.DEPARTMENT_ID  -- where절에 조인조건을 넣고
   AND D.LOCATION_ID = 1700;              -- 다른 조건은 and연산자로 연결
   
-- 2. 부서명이 'Executive'인 부서에 근무하는 사원들의 EMPLOYEE_ID, LAST_NAME, DEPARTMENT_NAME을 조회하시오.
SELECT E.EMPLOYEE_ID, E.LAST_NAME, D.DEPARTMENT_NAME
  FROM DEPARTMENTS D INNER JOIN EMPLOYEES E
    ON D.DEPARTMENT_ID = E.DEPARTMENT_ID
 WHERE D.DEPARTMENT_NAME = 'Executive';
   
-- 3. 직업아이디(JOB_ID)가 변하지 않은 사원들의 EMPLOYEE_ID, LAST_NAME, JOB_ID를 조회하시오.
--    현재 JOB_ID(EMPLOYEES)와 과거 JOB_ID(JOB_HISTORY)가 일치하는 사원을 조회하시오.
SELECT E.EMPLOYEE_ID, E.LAST_NAME, J.JOB_ID
  FROM EMPLOYEES E INNER JOIN JOB_HISTORY J
    ON E.EMPLOYEE_ID = J.EMPLOYEE_ID
 WHERE E.JOB_ID = J.JOB_ID;
 
-- 4. 부서별(GROUP BY)로 사원수와 평균연봉을 DEPARTMENT_NAME과 함께 조회하시오.
--    평균연봉은 정수로 절사(TRUNC)하고, 사원수의 오름차순(ASC) 정렬하시오.
-- *은 행을 카운트하기 때문에 안전. 
-- 특정칼럼을 지정해서 카운트하면 간혹 그 칼럼에 데이터가 없을 수 있는 경우 온전히 모두 카운트를 하지 못할 수 있기 때문에!
SELECT COUNT(*) AS 사원수, TRUNC(AVG(SALARY)), D.DEPARTMENT_NAME
  FROM DEPARTMENTS D INNER JOIN EMPLOYEES E
    ON D.DEPARTMENT_ID = E.DEPARTMENT_ID
 GROUP BY D.DEPARTMENT_NAME, D.DEPARTMENT_ID  -- ID로 그룹화하는 것이 안전함. ID가 다르면 이름이 같아도 다른 부서일 수 있기 때문에! group by의 칼럼은 select절에 하나만 들어가도 ok
 ORDER BY 사원수;
 
 -- 5. CITY가 'S'로 시작하는 지역에 근무하는 사원들의 EMPLOYEE_ID, LAST_NAME, DEPARTMENT_NAME, CITY를 조회하시오.
--    EMPLOYEE_ID의 오름차순 정렬로 조회하시오.
-- DEPARTMENTS 테이블 : DEPARTMENT_NAME
-- EMPLOYEES   테이블 : EMPLOYEE_ID, LAST_NAME
-- LOCATIONS   테이블 : CITY
SELECT E.EMPLOYEE_ID, E.LAST_NAME, D.DEPARTMENT_NAME, L.CITY
  FROM DEPARTMENTS D INNER JOIN EMPLOYEES E                       -- D와 E 조인 걸고, D와 E의 조인 조건에 L을 조인!
    ON D.DEPARTMENT_ID = E.DEPARTMENT_ID INNER JOIN LOCATIONS L   -- 3단 조인
    ON L.LOCATION_ID = D.LOCATION_ID
 WHERE L.CITY LIKE 'S%'  -- where절에서 LIKE는 특정문자열이 포함되어 있는지 검색할 때 사용!!!!!!
 ORDER BY E.EMPLOYEE_ID;
 
SELECT E.EMPLOYEE_ID, E.LAST_NAME, D.DEPARTMENT_NAME, L.CITY
  FROM DEPARTMENTS D, EMPLOYEES E, LOCATIONS L
 WHERE D.DEPARTMENT_ID = E.DEPARTMENT_ID
   AND D.LOCATION_ID = L.LOCATION_ID
   AND L.CITY LIKE 'S%'
 ORDER BY E.EMPLOYEE_ID;

-- 6. 모든 사원들의 EMPLOYEE_ID, LAST_NAME, DEPARTMENT_NAME, CITY, COUNTRY_NAME을 조회하시오. (테이블4개 필요)
--    단, DEPARTMENT_ID가 없는 사원은 조회하지 마시오. 
SELECT EMPLOYEE_ID, LAST_NAME, DEPARTMENT_NAME, CITY, COUNTRY_NAME
  FROM DEPARTMENTS D INNER JOIN EMPLOYEES E
    ON D.DEPARTMENT_ID = E.DEPARTMENT_ID INNER JOIN LOCATIONS L  -- NULL값 제외함
    ON L.LOCATION_ID = D.LOCATION_ID INNER JOIN COUNTRIES C
    ON C.COUNTRY_ID = L.COUNTRY_ID;
--- WHERE D.DEPARTMENT_ID IS NOT NULL;   JOIN 조건은 NULL값이 제외된 상태로 처리하기 때문에 굳이 WHERE절에 IS NOT NULL 처리가 필요없다.
 
 
 
/* OUTER JOIN */

-- 7. 모든 사원들의 EMPLOYEE_ID, LAST_NAME, DEPARTMENT_NAME을 조회하시오.
--    부서번호(DEPARTMENT_ID)가 없는 사원도 조회하고, EMPLOYEE_ID순으로 오름차순 정렬하시오.
--    부서번호(DEPARTMENT_ID)가 없는 사원의 부서명(DEPARTMENT_NAME)은 'None'으로 조회하시오. 
-- >>>>>>>> 부서번호가 없는 사원도 출력해야 하니까 OUTER JOIN. 부서번호가 없는 사원은 EMPLOYEES 테이블에 있으니 EMPLOYEES쪽으로 외부 조인.
--         부서(PK)               사원(FK)
--    일치하는정보포함(+)       모든정보포함
SELECT E.EMPLOYEE_ID, E.LAST_NAME, NVL(D.DEPARTMENT_NAME, 'NoneEEEEEEEE')
  FROM DEPARTMENTS D RIGHT OUTER JOIN EMPLOYEES E    -- 오른쪽에 있는 사원 테이블의 모든 정보 포함을 위해 RIGHT JOIN
    ON D.DEPARTMENT_ID = E.DEPARTMENT_ID
 ORDER BY E.EMPLOYEE_ID ASC;
 
SELECT E.EMPLOYEE_ID, E.LAST_NAME, NVL(D.DEPARTMENT_NAME, 'NoneEEEEEEEE')
  FROM DEPARTMENTS D, EMPLOYEES E
 WHERE D.DEPARTMENT_ID(+) = E.DEPARTMENT_ID    -- JOIN을 쓰지 않을 때는 전체 정보를 포함하지 않는 쪽에 (+)를 붙임
 ORDER BY E.EMPLOYEE_ID;
 
-- 8. 부서별 근무하는 사원수를 조회하시오.
--    단, 근무하는 사원이 없으면 0으로 조회하시오.
-- >>>>>>> 근무하는 사원이 없는 부서도 출력해야 하므로 OUTER JOIN. 근무하는 사원이 없는 부서의 정보는 DEPARTMENTS에 있으니 DEPT쪽으로 외부 조인.
SELECT D.DEPARTMENT_ID, D.DEPARTMENT_NAME, COUNT(E.DEPARTMENT_ID)
  FROM DEPARTMENTS D LEFT OUTER JOIN EMPLOYEES E   -- 무조건 모두 포함시켜야 되는 데이터는 'DEPARTMENTS'
    ON D.DEPARTMENT_ID = E.DEPARTMENT_ID
 GROUP BY D.DEPARTMENT_ID, D.DEPARTMENT_NAME;
-- ( * )로 해버리면, 또 (D.DEPARTMENT_ID)로 해버리면 부서는 있는데 근무하는 사원이 없는데 있는 것처럼 카운팅됨.
-- 실제로 실행하면 D기준 D_ID로 카운트하면 근무사원이 없는데도 다 1이라고 뜸..
-- 따라서 EMPLOYEES 테이블 기준으로 존재하는 부서를 카운팅해야하기 때문에 COUNT의 기준은 E가 됨

SELECT D.DEPARTMENT_ID, D.DEPARTMENT_NAME, COUNT(E.DEPARTMENT_ID)
  FROM DEPARTMENTS D, EMPLOYEES E
 WHERE D.DEPARTMENT_ID = E.DEPARTMENT_ID(+)  -- LEFT JOIN이니까 반대쪽에 (+) 붙여주기
 GROUP BY D.DEPARTMENT_ID, D.DEPARTMENT_NAME;
 
 
 
/* SELF JOIN */
-- 셀프조인하는 테이블이 2개라고 생각하면 된다. A_TBL C INNER JOIN A_TBL D

-- 9. MANAGER보다 먼저 입사한 사원들의 EMPLOYEE_ID, LAST_NAME, HIRE_DATE과 MANAGER의 HIRE_DATE를 조회하시오.
--    사원의 HIRE_DATE가 MANAGER의 HIRE_DATE보다 작은 사원을 조회하시오. (MANAGER보다 먼저 입사한 사원)
-- 비교 대상
-- 1) 모든 사원 정보 : EMPLOYEE E  
-- 2) MANAGER의 정보 : EMPLOYEE M
SELECT E.EMPLOYEE_ID, E.LAST_NAME AS 사원이름, E.HIRE_DATE, M.LAST_NAME AS 매니저이름, M.HIRE_DATE
  FROM EMPLOYEES E INNER JOIN EMPLOYEES M     -- JOIN 조건 : EMPLOYEE_ID = MANAGER_ID  사원들의 매니저정보와 매니저의 사원번호가 같음
    ON E.MANAGER_ID = M.EMPLOYEE_ID    -- E테이블의 MANAGER_ID와 M테이블의 EMPLOYEE_ID가 같다. 반대로 적으면 정보 틀리게 조회됨.
 WHERE E.HIRE_DATE < M.HIRE_DATE;

-- 10. 같은 부서의 사원들 중에서 나보다 늦게 입사하였으나 연봉을 더 많이 받는 사원이 있는 사원들의
--     DEPARTMENT_ID, LAST_NAME, SALARY, HIRE_DATE와 높은 연봉을 받는 사원의 LAST_NAME, SALARY, HIRE_DATE를 조회하시오.
SELECT E1.DEPARTMENT_ID, E1.LAST_NAME, E1.SALARY, E1.HIRE_DATE, E2.LAST_NAME, E2.SALARY, E2.HIRE_DATE
  FROM EMPLOYEES E1 INNER JOIN EMPLOYEES E2
    ON E1.DEPARTMENT_ID = E2.DEPARTMENT_ID   -- 같은 부서 사원들 중에서 비교하는 거니까 부서번호를 조인 조건으로.
 WHERE TO_DATE(E1.HIRE_DATE) < TO_DATE(E2.HIRE_DATE)  -- TO_DATE 안 해도 됨.
   AND E1.SALARY < E2.SALARY;

